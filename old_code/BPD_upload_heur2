    if False:
        PP = PathPlanner()
        PP.setR(R)

        # load danger zones into the path planner
        for dz in DZL:
            PP.addDangerZone(dz.string_poly)

        for n, d in BPD.graph.nodes(data=True):

            if d["bipartite"] == 1:
                continue

                # get ccordinates
            pnodes = d["vrtx"].edge
            pi = func.get_coords_for_node(pnodes[0], TOPOLOGY)
            pg = func.get_coords_for_node(pnodes[1], TOPOLOGY)

            # get adjacent danger zones
            neigh_cuts = [v for v in BPD.graph.nodes if BPD.graph.has_edge(n, v)]
            d["neigh"] = len(neigh_cuts)
            ids = set()
            for c in neigh_cuts:
                ids.update(BPD.return_ids_for_cut(c))
            ids = list(ids)

            # calculate cost
            PP.calculate_r_detour(pi, pg, ids)
            cost = PP.getCost()
            path = PP.getPath()

            # update node
            d["path"] = path
            d["cost"] = cost
            d["ids"] = set(ids)

        logging.debug('BPD loaded with costs.')
        logging.debug(f'Time needed: {time.time() - start_time}')
        start_time = time.time()